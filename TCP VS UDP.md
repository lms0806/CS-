# TCP VS UDP

### 전송계층
 - TCP와 UDP는 TCP/IP의 전송계층에서 사용되는 포로토콜이다.
 - 전송 계층은 IP에 의해 전달되는 패킷의 오류를 검사하고 재전송 및 요구 등을 제어를 담당하는 계층

### TCP
 - 신뢰성을 보장하는 연결형 서비스

특징
 - 연결형 서비스
   - 3-way handshaking 과정을 통해 연결을 설정
   - 4-way handshaking 을 통해 연결 해제
 - 흐름제어 (Flow control)
   - 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우 방지
   - 수신자가 윈도우 크기 값을 통해 수신량을 정할 수 있음
 - 혼잡 제어 (Congestion control)
   - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지
 - 신뢰성 높은 전송(Reliable transmission)
   - Dupack-based retransmission
     - 정상적인 상황에서는 ACK 값이 연속적으로 전송되어야 하지만, ACK값이 중복으로 올 경우 패킷 이상을 감지하고 재전송을 요청함
   - Timeout-based Retransmission
     - 일정시간동안 ACK 값이 수신을 못할 경우 재전송을 요청함
 - 전이중, 점대점 방식
   - 전이중 (Full-Duplex)
     - 전송이 양방향으로 동시에 일어날 수 있다.
   - 점대점 (Point to Point)
     - 각 연결이 정확히 2개의 종단점을 가지고 있다.

TCP Connection (3-way handshake)
 - open()을 실행한 클라이언트가 SYN을 보내고 SYN_SENT 상태로 대기
 - 서버는 SYN_RCVD 상태로 바꾸고 SYN과 응답 ACK를 보냄
 - SYN과 응답 ACK를 받은 클라이언트는 ESTABLISHED 상태로 변경하고 서버에서 응답 ACK를 보냄
 - 응답 ACK를 받은 서버는 ESTABLISHED 상태로 변경

TCP Disconnection (4-way handshake)
 - close()를 실행한 클라이언트가 FIN을 보내고 FIN_WAIT1 상태로 대기
 - 서버는 CLOSE_WAIT으로 바꾸고 응답 ACK를 전달, 동시에 해당 포트에 연결되어 있는 어플리케이션에게 close()를 요청
 - ACK를 받은 클라이언트는 상태르 FIN_WAIT2로 변경
 - close() 요청을 받은 서버 애플리케이션은 종료 프로세스를 진행하고 FIN을 클라이언트에 보내 LASK_ACK 상태로 바꿈
 - FIN을 받은 클라이언트는 ACK를 서버에 다시 전송하고 TIME_WAIT으로 상태를 바꿈, TIME_WAIT에서 일정 시간이 지나면 CLOSED됨, ACK를 받은 서버도 포트를 CLOSED로 닫음

데이터 송신 과정
 - (1) 지금 수신 가능한지 체크(송 -> 수)
 - (2) 가능(수 -> 송)
 - (3) 데이터 전송(송 -> 수)
 - (4) 데이터가 잘 도착했는지 확인(송 -> 수)
 - (5) 데이터가 잘 도착했다고 확인(수 -> 송)

### UDP
데이터 송신 과정
 - 데이터 보냄(송 -> 수)

| TCP | UDP |
| 연결지향형 프로토콜 | 비 연결지향형 프로토콜 |
| 바이트 스트림을 통한 연결 | 메시지 스트림을 통한 연결 |
| 혼잡제어, 흐름제어 | 혼잡제어와 흐름제어 지원 x |
| 순서 보장, 상대적으로 느림 | 순서 보장되지 않음, 상대적으로 빠름 |
| 신뢰성 있는 데이터 전송 - 안정적 | 데이터 전송 보장 x |
| 세그먼트 TCP 패킷 | 데이터그램 UDP 패킷 |
| HTTP, Email, File transfer에서 사용 | 도메인, 실시간 동영상 서비스에서 사용 |

### 공통점
 - 포트 번호를 이용하여 주소를 지정
 - 데이터 오류 검사를 위한 체크섬 존재

### 차이점
TCP
 - 연결이 성공해야 통신 가능
 - 데이터의 경계를 구분하지 않음
 - 신뢰성 있는 데이터 전송
 - 일 대 일 통신

UDP
 - 비연결형 프로토콜
 - 데이터의 경계를 구분함
 - 비신뢰성 있는 데이터 전송
 - 일 대 일, 일 대 다, 다 대 다 통신
